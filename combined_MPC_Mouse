# --- Acados and MPC Imports ---
from acados_template import AcadosOcp, AcadosOcpSolver, AcadosSimSolver
from pendulum_model import export_pendulum_ode_model
from casadi import vertcat

import pygame
import numpy as np
from pygame.locals import *
import socket
import json

# Define physical constants in SI units
M = 0.5  
m = 1.0  
g = -9.81/5 
l = 2.0  
dt = 0.01  
cart_width = 0.3  
cart_height = 0.1
cart_y_coord = 350

# Define scaling factors to convert SI units to pixels
scale_factor = 100

# Pygame settings
WIDTH = 600
HEIGHT = 400
FPS = 1 / dt  

# Initial conditions in SI units
x1_SI = 0.0
theta_SI = np.pi  
x1_dot_SI = 0.0  
theta_dot_SI = 0.0  
x1_ddot_SI = 0.0
theta_ddot_SI = 0.0
x1_ref_SI = 0.0
prev_x_SI = 0.0

K = 250
D = 5

# Score variables
score = 0.0
high_score = 0.0  

# Game state variables
game_over = False  
simulation_time = 0.0  # Track elapsed time

# Initialize Pygame
pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
clock = pygame.time.Clock()

# Define font for score display
font = pygame.font.Font(None, 36)

# Ports
SEND_PORT = 5005  # Send to Haptic
RECV_PORT = 5006  # Receive from Haptic
UDP_IP = "127.0.0.1"  # Localhost

# Create UDP sockets
send_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  # For sending
recv_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  # For receiving

recv_sock.bind((UDP_IP, RECV_PORT))  # Bind receiving socket
recv_sock.setblocking(False)  # Set non-blocking

def display_message(message):
    """Displays a message on the screen."""
    screen.fill((255, 255, 255))  # Clear screen
    text = font.render(message, True, (0, 0, 0))
    screen.blit(text, (WIDTH // 2 - 150, HEIGHT // 2))
    pygame.display.flip()

def convert_to_pixels(value, scale_factor):
    return value * scale_factor

def update_physics(theta, theta_dot, F):
    cos_theta = np.cos(theta)
    sin_theta = np.sin(theta)
    # denominator = M + m - m * sin_theta ** 2

    # theta_ddot = (-m * l * cos_theta * sin_theta * theta_dot ** 2 + F * cos_theta + (M + m) * g * sin_theta) / (l * denominator)
    # x1_ddot = (-m * l * sin_theta * theta_dot ** 2 + m * g * cos_theta * sin_theta + F) / denominator

    theta_ddot = (F * cos_theta - m * l * theta_dot ** 2 * sin_theta * cos_theta + g * sin_theta) / (l * (M + m - m * cos_theta ** 2))
    x1_ddot = (F + m * l * theta_ddot * cos_theta - m * l * theta_dot **2 * sin_theta) / ( (M + m))
    return x1_ddot, theta_ddot

def draw_system(x1, theta, score, high_score, game_over, fps, time_left):
    rod_length_SI = convert_to_pixels(l, scale_factor)  
    cart_width_SI = convert_to_pixels(cart_width, scale_factor)
    cart_height_SI = convert_to_pixels(cart_height, scale_factor)
    pendulum_x = x1 - rod_length_SI * np.sin(theta)
    pendulum_y = cart_y_coord + rod_length_SI * np.cos(theta)  

    screen.fill((255, 255, 255))

    pygame.draw.line(screen, (0, 0, 0), (x1, cart_y_coord), (pendulum_x, pendulum_y), 3)  
    pygame.draw.circle(screen, (255, 0, 0), (int(pendulum_x), int(pendulum_y)), 10)  
    pygame.draw.rect(screen, (0, 0, 255), (x1 - cart_width_SI / 2, cart_y_coord, cart_width_SI, cart_height_SI))  

    # --- Display Text ---
    score_text = font.render(f"Score: {score:.2f}", True, (0, 0, 0))
    high_score_text = font.render(f"High Score: {high_score:.2f}", True, (0, 0, 0))
    fps_text = font.render(f"FPS: {fps:.1f}", True, (0, 0, 0))
    timer_text = font.render(f"Time Left: {time_left:.1f} s", True, (255, 0, 0))  

    # Positioning Text
    screen.blit(score_text, (20, 20))
    screen.blit(high_score_text, (20, 50))
    screen.blit(fps_text, (20, 80))  
    screen.blit(timer_text, (WIDTH - 200, 20))  

    if game_over:
        game_over_text = font.render("GAME OVER - Press 'R' to Restart", True, (255, 0, 0))
        screen.blit(game_over_text, (WIDTH // 2 - 200, HEIGHT // 2))


# --- MPC Setup Function using acados ---
def setup_mpc(x0, Fmax, N_horizon, Tf, RTI=False):
    # Create the OCP object
    ocp = AcadosOcp()

    # Set the model (pendulum)
    model = export_pendulum_ode_model()
    ocp.model = model

    nx = model.x.rows()
    nu = model.u.rows()
    ny = nx + nu
    ny_e = nx

    # Set cost module (using a nonlinear least-squares cost)
    ocp.cost.cost_type = 'NONLINEAR_LS'
    ocp.cost.cost_type_e = 'NONLINEAR_LS'

    Q_mat = 2 * np.diag([1e3, 1e3, 1e-2, 1e-2])
    R_mat = 2 * np.diag([1e-2])
    from scipy.linalg import block_diag  # Block-diagonal weight matrix
    ocp.cost.W = block_diag(Q_mat, R_mat)
    ocp.cost.W_e = Q_mat

    ocp.model.cost_y_expr = vertcat(model.x, model.u)
    ocp.model.cost_y_expr_e = model.x

    yref = np.zeros((ny,))
    yref[1] = np.pi  # Target: Pendulum upright

    yref_e = np.zeros((ny_e,))
    yref_e[1] = np.pi  # Terminal reference

    ocp.cost.yref = yref
    ocp.cost.yref_e = yref_e

    # Set constraints on the control input
    ocp.constraints.lbu = np.array([-Fmax])
    ocp.constraints.ubu = np.array([+Fmax])
    ocp.constraints.idxbu = np.array([0])
    ocp.constraints.x0 = x0

    # Set prediction horizon
    ocp.solver_options.N_horizon = N_horizon
    ocp.solver_options.tf = Tf

    # Solver options
    ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'
    ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'
    ocp.solver_options.integrator_type = 'IRK'
    ocp.solver_options.sim_method_newton_iter = 10

    if RTI:
        ocp.solver_options.nlp_solver_type = 'SQP_RTI'
    else:
        ocp.solver_options.nlp_solver_type = 'SQP'
        ocp.solver_options.globalization = 'MERIT_BACKTRACKING'
        ocp.solver_options.nlp_solver_max_iter = 150

    ocp.solver_options.qp_solver_cond_N = N_horizon

    # Save to a JSON file (required by acados)
    solver_json = 'acados_ocp_' + model.name + '.json'
    acados_ocp_solver = AcadosOcpSolver(ocp, json_file=solver_json)
    acados_integrator = AcadosSimSolver(ocp, json_file=solver_json)

    return acados_ocp_solver, acados_integrator


def main():
    global x1_SI, theta_SI, x1_dot_SI, theta_dot_SI, prev_x_SI, score, high_score, game_over, simulation_time
    running = True
    simulation_running = False

    # Step 1: Show Initial Waiting Screen
    display_message("Initializing MPC... Please wait.")

    x0 = np.array([0.0, 0.0, 0.0, 0.0])  # Initial state
    Fmax = 80
    Tf = 0.6
    N_horizon = 60
    assert(Tf/N_horizon == dt)
    
    F_send = np.array([0, 0])
    # Setup MPC using acados
    ocp_solver, integrator = setup_mpc(x0, Fmax, N_horizon, Tf, RTI=True)

    # Step 3: Once MPC is ready, show "Press E to Start"
    display_message("Press 'E' to start.")
    
    # Initialize simulation state
    current_state = np.array([x1_SI, theta_SI, x1_dot_SI, theta_dot_SI])


    while running:
        for event in pygame.event.get():
            if event.type == QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_r:
                    x1_SI = x1_ref_SI
                    prev_x_SI = x1_ref_SI
                    theta_SI = np.pi
                    x1_dot_SI = 0.0
                    theta_dot_SI = 0.0
                    x1_ddot_SI = 0.0
                    theta_ddot_SI = 0.0
                    score = 0.0  
                    simulation_time = 0.0  
                    game_over = False  
                if event.key == pygame.K_q:
                    running = False
                if event.key == pygame.K_e and not game_over:
                    simulation_running = True
                    message = json.dumps(F_send.tolist())  # Convert to JSON string
                    send_sock.sendto(message.encode(), (UDP_IP, SEND_PORT))

        if simulation_running and not game_over:
            # mouse_x, _ = pygame.mouse.get_pos()
            # x1_ref_SI = (mouse_x - WIDTH // 2) / scale_factor

            # --- Solve MPC ---
            # current_state = np.array([x1_SI, theta_SI, x1_dot_SI, theta_dot_SI])
            # ocp_solver.set(0, "lbx", current_state)
            # ocp_solver.set(0, "ubx", current_state)
            # status = ocp_solver.solve()
            # if status != 0:
            #     print("MPC solver returned status", status)
            
            # u = ocp_solver.get(0, "u")  # Get optimal control input

            # Try to receive data from Haptic script (non-blocking)
            try:
                data, addr = recv_sock.recvfrom(1024)
                position, _ = json.loads(data.decode())
                # print(f"Received from Haptic: {position}")

                x1_ref_SI = (position - WIDTH // 2) / scale_factor

                x1_dot_SI = (x1_SI - prev_x_SI) / dt
                F = K * (x1_ref_SI - x1_SI) - D * x1_dot_SI

                x1_ddot_SI, theta_ddot_SI = update_physics(theta_SI, theta_dot_SI, F)
                
                current_state = np.array([x1_SI, theta_SI, x1_dot_SI, theta_dot_SI])
                ocp_solver.set(0, "lbx", current_state)
                ocp_solver.set(0, "ubx", current_state)
                status = ocp_solver.solve()
                if status != 0:
                    print("MPC solver returned status", status)
                
                u = ocp_solver.get(0, "u")  # Get optimal control input

                F_send = np.array([-u[0]/40, 0])
                message = json.dumps(F_send.tolist())  # Convert to JSON string
                send_sock.sendto(message.encode(), (UDP_IP, SEND_PORT))

                x1_dot_SI += x1_ddot_SI * dt
                x1_SI += x1_dot_SI * dt
                theta_dot_SI += theta_ddot_SI * dt
                theta_SI += theta_dot_SI * dt

                prev_x_SI = x1_SI
            except BlockingIOError:
                pass  # No data available, continue execution

            # x1_dot_SI = (x1_SI - prev_x_SI) / dt
            # F = K * (x1_ref_SI - x1_SI) - D * x1_dot_SI

            # x1_ddot_SI, theta_ddot_SI = update_physics(theta_SI, theta_dot_SI, F)
            
            # x1_dot_SI += x1_ddot_SI * dt
            # x1_SI += x1_dot_SI * dt
            # theta_dot_SI += theta_ddot_SI * dt
            # theta_SI += theta_dot_SI * dt

            # prev_x_SI = x1_SI
            
            # **Check if pendulum crosses the horizontal**
            if theta_SI <= np.pi / 2 or theta_SI >= 3 * np.pi / 2:
                game_over = True
                print("GAME OVER! Pendulum fell past horizontal.")

            # **Score Calculation:**
            score += dt * (1 - abs(np.pi - theta_SI) / np.pi)  
            if score > high_score:
                high_score = score  

            # **Game Over After 15 Seconds**
            simulation_time += dt
            if simulation_time >= 15.0:
                game_over = True
                print("GAME OVER! Time limit reached.")
            time_left = max(15.0 - simulation_time, 0)  # Calculate remaining time

            # Calculate FPS
            true_fps = clock.get_fps()

            # Draw System
            x1_pixels = convert_to_pixels(x1_SI, scale_factor)
            draw_system(x1_pixels + WIDTH // 2, theta_SI, score, high_score, game_over, true_fps, time_left)
            pygame.display.flip()

            clock.tick(FPS)

    pygame.quit()

if __name__ == '__main__':
    main()
